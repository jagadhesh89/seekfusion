#!/bin/bash

read -r -d '' DOCS <<DOCS
autoRun.sh bash script

This script will watch for UMIFUSION pipeline breadcrumb files to know when conversion is complete. These files
must match the following naming scheme: UMIFUSION_*.process.

Within each process breadcrumb file the second line should
contain run information in the following format:
    <test>,<program>,<run id>,<sample1>;<sample2>

Any breadcrumb found to be in error will be sent to: <STAGE_PATH>/runs/automation/error
Any UMIFUSION breadcrumb older than one day will automatically be considered stale and be treated as an error.

OPTIONS:
   -h      help, Show this message
   -d      debug, turn on debug

CONFIG:
Add new automation entries ("umiFusionAnalysis") to the test definition files (os.cfg)

EMAIL_ADDRESS_FROM=someone@mayo.edu

DESIGN:
   a. Does not support explicit input parameters of sample sheet and run directory.
   b. No bread crumbs will get cleaned up for the near future.
   c. This script will support cron jobs (with runs @ time intervals) via tu06332 account
   d. Stale breadcrumbs are used in lieu of writing to logs, checking failures, and notifying only once on a failure
   e. There are no qsub calls in here (runBmd is called to perform actual processing).
   f. prog2pipe() is not called in here.
   g. The last state in a given *.process file is considered the current state of the process.
   h. We key off of the file system foreach sample and do not use the current CRUMBS's SAMPLES column

EXAMPLES:
   ./autoRunUmiFusion.sh

typical RunInfo -- UMIFUSION_NGS71_60217_LIB027_IL028A_B5JJT
RECIPE,LOCATION,RUN_ID,SAMPLES
NGS71,NGS71/NGS71_60217_LIB027_IL028A_B5JJT,,N002-200ng;N009-200ng
READY


DOCS

set -o pipefail
set -o nounset

#################################################
#Find Pipeline Profile
##################################################

SCRIPT=$( readlink -m $( type -p $0 ))
SCRIPT_DIR=$(dirname ${SCRIPT})
SCRIPT_NAME=$(basename ${SCRIPT})
SCRIPT_ROOT="$(dirname "$(dirname ${SCRIPT})")"
SCRIPT_SOURCES="$(dirname ${SCRIPT_ROOT})"
SCRIPT_DEPLOY_HOME="$(dirname ${SCRIPT_SOURCES})"
PIPELINE_PROFILE=$(readlink -m "${SCRIPT_DEPLOY_HOME}/umifusion.profile")

if [[ ! -f ${PIPELINE_PROFILE} ]]; then
    echo "Umifusion profile not found: ${PIPELINE_PROFILE}"
    exit 1
fi
echo -e "Using configuration file: ${PIPELINE_PROFILE}"
source ${PIPELINE_PROFILE}

COMMON_FUNC="${UTILITIES}/src/main/bash/commonFunctions.sh"
if [[ ! -f ${COMMON_FUNC} ]]; then
    echo -e "\nERROR: The common UTILITIES do not appear to be installed: ${UTILITIES}\n"
    exit 1
fi

echo "Using common functions: ${COMMON_FUNC}"
source "${COMMON_FUNC}"

#script constants set in umifusion.profile profile
PROCESS_NAME="UMIFusion"
PROCESS_STARTED="UMIFusion processing started"
RUN_PROCESS="${SCRIPT_SOURCES}/main/shell/runFusion.sh"
EMAIL_FROM="${EMAIL_ADDRESS_FROM}"
EMAIL_TO="${EMAIL_ADDRESS}" # this is the mailing list for UMIFusion Errors
END_OF_CONVERSION_MARKER="Ready for pipeline processing" # generated by instrumentation when run is fully staged for secondary

runDebug=""
while getopts "hd" OPTION
do
    case $OPTION in
	h) echo "${DOCS}" ; exit ;;
	d) set -o xtrace  ; runDebug="-d" ;;
    esac
done

function errorNotification(){
  MESSAGE="${1}"
  SUBJECT="Possible issue with ${PROCESS_NAME} umifusion automation in ${STAGE_NAME}"
  echo "${MESSAGE}"
  echo -e ${MESSAGE} | /bin/mail -r ${EMAIL_FROM} -s "${SUBJECT}" -a ${CRUMB} ${EMAIL_TO}
  sleep 1

  ERROR_FOLDER="${AUTOMATION_RUN_HOME}/error"
  if [ ! -d ${ERROR_FOLDER} ]; then
    mkdir -p "${ERROR_FOLDER}"
  fi
  mv ${CRUMB} ${ERROR_FOLDER}
}

#returns 0 if the crumb is stale or if there is no crumb.
function checkForStaleCrumb(){
  if [ ! -f ${CRUMB} ]; then
      return 0
  fi

  OLD_CRUMB=$(find ${CRUMB} -type f -mtime +1)
  if [ ! -z ${OLD_CRUMB} ]; then
    MSG="Crumb: ${CRUMB} is more than one day old, and should be looked at. It has been moved to the error folder."
    errorNotification "${MSG}"
    return 0
  fi

  return 1
}

function checkForAndRun(){

  if [[ -f ${CRUMB} && `tail -1 ${CRUMB}` =~ ${END_OF_CONVERSION_MARKER} ]]; then
      echo "${ORDERED_SERVICE} is ready for secondary analysis"

      # calls runFusionBatch.sh on all samples in samples folder -
      # refactor for runFusion.sh for individual sample runs

      for SAMPLE in "${SAMPLE_LIST[@]}"; do
          echo "Sample: ${SAMPLE}"
          echo "Crumb: ${CRUMB}"
          CMD="${RUN_PROCESS} -i ${RUN_DATA}/${SAMPLE_PROJECT}/samples/${SAMPLE} ${runDebug} "
          echo "issuing CMD: $CMD"
          echo "issuing CMD: $CMD" >> ${CRUMB}
          CMD_OUT=`${CMD}`
          echo ${CMD_OUT}
          echo ${CMD_OUT} >> ${CRUMB}
      done
      #signal that a job has been started (is running)
      echo "`date` ${PROCESS_STARTED}" >> ${CRUMB}
  fi
}

#returns 0 if process has completed.
function checkForCompletion(){

    for SAMPLE in "${SAMPLE_LIST[@]}"; do
        SAMPLE_PATH="${RUN_DATA}/${SAMPLE_PROJECT}/samples/${SAMPLE}"

	    ## If the third column reads COMPLETED, the pipeline finished
	 	OUT_FILE="${SAMPLE_PATH}/${PIPELINE_NAME,,}/reports/pipeline_results.txt"

        #  pipeline_results.txt missing
        if [ ! -f "${OUT_FILE}" ]; then
            return 1
        fi

        if [[ ! `tail -1 ${OUT_FILE} | cut -f2 ` =~ "COMPLETED" ]]; then
            return 1
        fi
    done
    return 0
}

#returns 0 if UMIFusion is still running
function StillRunning(){
    checkForCompletion
    if [ $? -eq 0 ]; then
	    return 1
    fi
    if [[ -f ${CRUMB} && `grep -o "${PROCESS_STARTED}" ${CRUMB}` ]]; then
	    echo "`date` ${PROCESS_NAME} is still running: ${CRUMB}"
	    return 0
    fi
    return 1
}

echo "Looking for crumbs in: $AUTOMATION_RUN_HOME"

#BEGIN MAIN LOOP
# Check for samples that are ready for processing using prog2pipe (casava) generated crumb files
#NOTE-- We key off of the file system foreach sample and do not use the current CRUMBS's sample

for CRUMB in $(find ${AUTOMATION_RUN_HOME} -maxdepth 1 -name UMIFUSION_\* ) ; do
    echo "Found crumb: ${CRUMB}"

    # This pulls the 2nd line from the crumb
    RUN_INFO=$(sed -n '2p' ${CRUMB})

    if [[ -z  ${RUN_INFO} ]]; then
    	errorNotification "Run information is missing from crumb: ${CRUMB}"
	    continue
    fi

    ORDERED_SERVICE=$(echo ${RUN_INFO} | cut -d, -f1 )
    SAMPLE_PROJECT=$(echo ${RUN_INFO} | cut -d, -f2 )
    RUN_ID=$(echo ${RUN_INFO} | cut -d, -f3 ) # not used
    SAMPLES=$(echo ${RUN_INFO} | cut -d, -f4 ) # separated by semi-colons
    SAMPLE_LIST=( $(echo ${SAMPLES} | tr ';' ' ') )

    checkForStaleCrumb  #This will handle possible failure notification errors and move stale crumbs
    if [ $? -eq 0 ]; then
    	continue
    fi

    checkForCompletion
    if [ $? -eq 0 ]; then
        # COMPLETED marks that fusion finished successfully
        # Generate its crumb for next time thru this loop
    	echo "`date` $0 finished for ${RUN_INFO}" >> ${CRUMB}
    	echo "`date` generating pipeline breadcrumbs" >> ${CRUMB}
    	echo "PROCESSED" >> ${CRUMB}  #this marker should not appear more than once
        mv ${CRUMB} ${AUTOMATION_PROCESSED_PATH}
	continue
    fi

    #At this point UMIFusion may still be running or not yet started
    StillRunning
    if [ $? -eq 0 ]; then
    	continue
    fi
    checkForAndRun
done

echo "`date` ${SCRIPT_NAME} finished"
exit 0
